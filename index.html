<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ojo 3D Interactivo</title>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    body { margin: 0; background: #000; }
    model-viewer { width: 100%; height: 100vh; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 10px;
      font-family: sans-serif;
      display: none;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <model-viewer 
       id="visor"
       src="Ojo_nuevo.glb" 
       auto-rotate 
       camera-controls 
       alt="Ojo 3D">
  </model-viewer>

  <div id="info"></div>

  <script>
    function normalizar(texto) {
      return texto
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/\s+/g, "")
        .toLowerCase();
    }

    const viewer = document.querySelector('#visor');
    const infoBox = document.querySelector('#info');
    const urlParams = new URLSearchParams(window.location.search);
    let clase = urlParams.get('clase');

    viewer.addEventListener('load', () => {
      const graph = viewer.sceneGraph;
      if (!graph) return;

      // Si viene parámetro en la URL (sigue funcionando)
      if (clase && !clase.toLowerCase().includes("todo")) {
        clase = normalizar(clase);
        resaltarParte(clase, graph);
      } else {
        ponerTodoGris(graph, 0.7);
      }
    });

    // Evento de clic para detectar la parte seleccionada
    viewer.addEventListener('click', async (event) => {
      const rect = viewer.getBoundingClientRect();
      const x = (event.clientX - rect.left) * viewer.clientWidth / rect.width;
      const y = (event.clientY - rect.top) * viewer.clientHeight / rect.height;

      // Calculamos el nodo bajo el clic
      const hit = await viewer.positionAndNormalFromPoint(x, y);
      if (!hit) return;

      const graph = viewer.sceneGraph;
      let nodoSeleccionado = null;

      graph.traverse((n) => {
        if (n === hit.node) nodoSeleccionado = n;
      });

      if (nodoSeleccionado) {
        ponerTodoGris(graph, 0.3);
        resaltarNodo(nodoSeleccionado);

        // Mostrar información
        infoBox.innerHTML = `<b>${nodoSeleccionado.name}</b>`;
        infoBox.style.display = 'block';
      }
    });

    // Funciones auxiliares
    function ponerTodoGris(graph, intensidad) {
      graph.traverse((n) => {
        if (n.material && n.material.pbrMetallicRoughness) {
          n.material.pbrMetallicRoughness.setBaseColorFactor([intensidad, intensidad, intensidad, 1]);
        }
      });
    }

    function resaltarParte(nombreClase, graph) {
      let nodoSeleccionado = null;
      ponerTodoGris(graph, 0.3);
      graph.traverse((n) => {
        if (n.name && normalizar(n.name).includes(nombreClase)) {
          nodoSeleccionado = n;
        }
      });
      if (nodoSeleccionado) resaltarNodo(nodoSeleccionado);
    }

    function resaltarNodo(nodo) {
      if (nodo.material && nodo.material.pbrMetallicRoughness) {
        nodo.material.pbrMetallicRoughness.setBaseColorFactor([1, 1, 0, 1]); // Amarillo
      }
    }
  </script>
</body>
</html>
